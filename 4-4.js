(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{399:function(t,i,n){"use strict";n.r(i),n.d(i,"MotionTrackerEvent",(function(){return a})),n.d(i,"MotionTracker",(function(){return h}));var r=n(42),s=n(302),e=n.n(s),o=function(t,i,n,r){return new(n||(n=Promise))((function(s,e){function o(t){try{h(r.next(t))}catch(t){e(t)}}function a(t){try{h(r.throw(t))}catch(t){e(t)}}function h(t){var i;t.done?s(t.value):(i=t.value,i instanceof n?i:new n((function(t){t(i)}))).then(o,a)}h((r=r.apply(t,i||[])).next())}))};class a{}class h extends r.a{constructor(t){super(t),this.canvas=document.createElement("canvas"),this.currentPyramid=new e.a.pyramid_t(3),this.previousPyramid=new e.a.pyramid_t(3),this.pointStatus=new Uint8Array(100),this.previousXY=new Float32Array(200),this.currentXY=new Float32Array(200),this.pointCount=0,this.windowSize=40,this.maxIterations=50,this.epsilon=.001,this.minEigen=1e-4,this.context=this.canvas.getContext("2d")}track(){return o(this,void 0,void 0,(function*(){yield this.player.loadPromise;const t=this.player.getAspectSize();this.currentPyramid.allocate(t[0],t[1],e.a.U8_t|e.a.C1_t),this.previousPyramid.allocate(t[0],t[1],e.a.U8_t|e.a.C1_t),[this.canvas.width,this.canvas.height]=t,this.buildPyramidFromVideoImage(this.currentPyramid),yield this.run(this.player.video.currentTime)}))}addPoint(t,i){this.currentXY[this.pointCount<<1]=t,this.currentXY[1+(this.pointCount<<1)]=i,++this.pointCount}buildPyramidFromVideoImage(t){const i=this.player.getAspectSize();this.context.drawImage(this.player.video,0,0,i[0],i[1]);const n=this.context.getImageData(0,0,i[0],i[1]),[r]=t.data;e.a.imgproc.grayscale(n.data,i[0],i[1],r),t.build(r,!0)}onFrame(t){return o(this,void 0,void 0,(function*(){const i=this.previousXY;this.previousXY=this.currentXY,this.currentXY=i;const n=this.previousPyramid;this.previousPyramid=this.currentPyramid,this.currentPyramid=n,this.buildPyramidFromVideoImage(this.currentPyramid),e.a.optical_flow_lk.track(this.previousPyramid,this.currentPyramid,this.previousXY,this.currentXY,this.pointCount,this.windowSize,this.maxIterations,this.pointStatus,this.epsilon,this.minEigen),this.prunePoints();const r=new a;0!==this.pointCount&&(r.found=!0,[r.x,r.y]=this.currentXY),r.progress=t.progress,yield this.onMotionFrame(r)}))}prunePoints(){let t=0,i=0;for(;t<this.pointCount;++t)1===this.pointStatus[t]&&(i<t&&(this.currentXY[i<<1]=this.currentXY[t<<1],this.currentXY[1+(i<<1)]=this.currentXY[1+(t<<1)]),++i);this.pointCount=i}}}}]);
//# sourceMappingURL=4-4.js.map